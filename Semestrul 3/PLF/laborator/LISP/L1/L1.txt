; 11.
; a) Sa se determine cel mai mic multiplu comun al valorilor numerice dintr-o lista neliniara.

;   _cmmmc(a: integer, b: integer)
;   a - int, primul numar
;   b - int, al doilea numar
;
;			nil, daca a si b nu sunt numere
;	cmmmc(a,b)=	b, daca a e nul
;			a, daca b e nul
;			a*b / _gcd(a,b), altfel
;



(defun _cmmmc (a b)
    (cond
        ((and (not (numberp a)) (not (numberp b))) nil)
        ((not (numberp a)) b)
        ((not (numberp b)) a)
        (T (/ (* a b) (_gcd a b)))
    )
)



;   _gcd(a: integer, b: integer)
;   a - int, primul numar
;   b - int, al doilea numar
;
;			nil, daca a si b nu sunt nule
;			b, daca a nu e nr
;	_gcd(a,b)=	a, daca b e nul
;			a, b=0
;			_gcd(b,a%b), altfel


(defun _gcd (a b)
    (cond
        ((and (not (numberp a)) (not (numberp b))) nil)
        ((not (numberp a)) b)
        ((not (numberp b)) a)
        ((equal b 0) a)
        (T (_gcd b (mod a b)))
    )
)


;   list_gcd(l: list)
;   
;
;				l1, daca n=1
;	list_gcd(l1l2...ln)=	l1, daca _cmmmc(list_gcd(l1), daca list_gcd(l2...ln))
;	 			_cmmmc(l1, list_gcd(l2...ln)), altfel



(defun list_gcd (l)
    (cond
        ((and (atom (car l)) (null (cdr l))) (car l))
        ((listp (car l)) (_cmmmc (list_gcd (car l)) (list_gcd (cdr l))))
        (T (_cmmmc (car l) (list_gcd (cdr l))))
    )
)

(print (list_gcd '(24 ( 16 (12 A B)) 72)))
;=> 144


; b) Sa  se  scrie  o  functie  care  sa  testeze  daca  o  lista  liniara  formata  din numere intregi are aspect de "munte"(o secvență se spune ca are aspect de "munte" daca elementele cresc pana la un moment dat, apoi descresc. De ex.10 18 29 17 11 10).

; _mountain(l: lista, decresing: integer) 
;	
;						Adevarat, daca n=1
;	_mountain(l1l2...ln, decresing)=	Fals, daca l1<l2 si decracing = Fals	
;						_mountain(l2...ln, fals), daca l1>l2 si decracing = Adevarat
;						_mountain(l2...ln, Adevarat), altfel

(defun _mountain (l decreasing)
	(cond
		((= (list-length l) 1) (if decreasing nil T))
		((and (< (car l) (cadr l)) (not decreasing)) nil)
		((and (> (car l) (cadr l)) decreasing) (_mountain (cdr l) nil))
		(T (_mountain (cdr l) decreasing))
	)
)

; mountain(l: lista)
;
;	mountain(l1l2...ln) =	nil, daca n<3
;				_mountain(l, Adevarat), altfel

(defun mountain (l)
	(if (< (list-length l) 3)
		nil
		(_mountain l T)
	)
)

(print (mountain '(29 17 11 10)))
; => T

(print (mountain '(10 18 29 17 11 29 10)))
;=> nil



; c) Sa  se  elimine  toate  aparitiile  elementului  numeric  maxim    dintr-o  lista neliniara.


; max_nb(a: integer, b:integer)
;			
;	max_nb(a,b)=	a b, daca a>b
;

(defun max_nb (a b)
    (if (> a b) a b)
)

; max_nb(l: list)
;
;				-1, daca l vida
;				l1, daca n=1
;	max_num(l1l2...ln)=	max_nb(l1, max_num(l2...ln)), daca
;				max_nb(max_num(l1), max_num(l2...ln)), daca
;				max_num(l2...ln), altfel

(defun max_num (l)
    (cond
        ((null l) -1)
        ((and (null (cdr l)) (numberp (car l))) (car l))
        ((numberp (car l)) (max_nb (car l) (max_num (cdr l))))
        ((listp (car l)) (max_nb (max_num (car l)) (max_num (cdr l))))
        (t (max_num (cdr l)))
     )
)

(print (max_num '(1 2 (3 (a) (1 3)) 4 5)))
; => 5


; d) Sa se construiasca o functie care intoarce produsul atomilor numerici pari dintr-o lista, de la orice nivel.

; productL(l: list)
;
;				
;	productL(l1l2...ln)=	l1, daca l=1
;				l1*l2...ln, altfel



(defun productL (l)
    (cond
        ((numberp l) l)
        ((atom l) 1)
        (T (apply '* (mapcar 'productL l)))
    )
)

(print (productL '(1 2 3 (4 5 (6)) (7))))
;=> 5040